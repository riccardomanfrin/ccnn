<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NeuralGraph Visualizer</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;700&family=Space+Grotesk:wght@300;500;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #070b14;
  --surface: #0d1526;
  --border: #1a2d4a;
  --accent: #00e5ff;
  --accent2: #7c3aed;
  --accent3: #f59e0b;
  --ok: #10b981;
  --danger: #ef4444;
  --text: #dde6f5;
  --muted: #4a6080;
  --r: 8px;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  background: var(--bg);
  color: var(--text);
  font-family: 'JetBrains Mono', monospace;
  height: 100vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
header {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px 20px;
  border-bottom: 1px solid var(--border);
  background: var(--surface);
  flex-shrink: 0;
}
header h1 {
  font-family: 'Space Grotesk', sans-serif;
  font-size: 17px;
  font-weight: 700;
  color: var(--accent);
  letter-spacing: -0.5px;
}
.tag {
  font-size: 9px;
  background: var(--accent2);
  color: #fff;
  padding: 2px 7px;
  border-radius: 20px;
  letter-spacing: 1px;
}
#batch-counter {
  margin-left: auto;
  font-size: 11px;
  color: var(--muted);
}
#batch-counter span { color: var(--accent3); font-weight: 700; }

.toolbar {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 7px 20px;
  border-bottom: 1px solid var(--border);
  background: var(--surface);
  flex-shrink: 0;
  flex-wrap: wrap;
}
.ctrl-group {
  display: flex;
  align-items: center;
  gap: 5px;
  padding: 3px 9px;
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: var(--r);
}
.ctrl-group label {
  font-size: 9px;
  color: var(--muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  white-space: nowrap;
}
.ctrl-group input[type=number] {
  width: 46px;
  background: transparent;
  border: none;
  color: var(--accent);
  font-family: 'JetBrains Mono', monospace;
  font-size: 13px;
  font-weight: 700;
  outline: none;
  text-align: center;
}
.sep { width: 1px; height: 24px; background: var(--border); margin: 0 4px; }
.btn {
  padding: 5px 13px;
  border-radius: var(--r);
  border: none;
  font-family: 'JetBrains Mono', monospace;
  font-size: 10px;
  font-weight: 700;
  letter-spacing: 0.4px;
  cursor: pointer;
  transition: all .12s;
  white-space: nowrap;
}
.btn-primary { background: var(--accent); color: var(--bg); }
.btn-primary:hover { filter: brightness(1.2); }
.btn-ok { background: var(--ok); color: #fff; }
.btn-ok:hover { filter: brightness(1.15); }
.btn-warn { background: var(--accent3); color: var(--bg); }
.btn-warn:hover { filter: brightness(1.15); }
.btn-danger { background: var(--danger); color: #fff; }
.btn-danger:hover { filter: brightness(1.15); }
.btn-ghost { background: transparent; color: var(--muted); border: 1px solid var(--border); }
.btn-ghost:hover { color: var(--text); border-color: var(--accent); }
.btn:disabled { opacity: 0.35; cursor: not-allowed; filter: none; }

.main { flex: 1; display: flex; overflow: hidden; }

.side {
  width: 320px;
  flex-shrink: 0;
  border-right: 1px solid var(--border);
  background: var(--surface);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.side-tabs { display: flex; border-bottom: 1px solid var(--border); }
.side-tab {
  flex: 1;
  padding: 8px 0;
  text-align: center;
  font-size: 9px;
  font-weight: 700;
  letter-spacing: 0.7px;
  text-transform: uppercase;
  color: var(--muted);
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all .12s;
}
.side-tab.active { color: var(--accent); border-bottom-color: var(--accent); }
.side-pane { display: none; flex: 1; flex-direction: column; overflow: hidden; }
.side-pane.active { display: flex; }
.side-scroll { flex: 1; overflow-y: auto; padding: 12px; scrollbar-width: thin; scrollbar-color: var(--border) transparent; }

.json-label {
  font-size: 9px;
  color: var(--muted);
  text-transform: uppercase;
  letter-spacing: 0.6px;
  margin-bottom: 4px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.json-label a { color: var(--accent); cursor: pointer; font-size: 9px; text-decoration: none; }
.json-label a:hover { text-decoration: underline; }
textarea {
  width: 100%;
  background: var(--bg);
  border: 1px solid var(--border);
  color: #a0c8e8;
  font-family: 'JetBrains Mono', monospace;
  font-size: 10px;
  line-height: 1.5;
  padding: 8px;
  border-radius: var(--r);
  resize: vertical;
  outline: none;
  min-height: 120px;
}
textarea:focus { border-color: var(--accent); }
.json-err { font-size: 9px; color: var(--danger); margin-top: 3px; min-height: 14px; }
.json-section { margin-bottom: 14px; }
.apply-btn { width: 100%; margin-top: 6px; }

#train-log {
  flex: 1;
  overflow-y: auto;
  padding: 10px 12px;
  font-size: 9px;
  color: var(--muted);
  line-height: 1.7;
  scrollbar-width: thin;
  scrollbar-color: var(--border) transparent;
}
.log-entry { border-bottom: 1px solid rgba(26,45,74,0.35); padding: 3px 0; }
.log-entry .li { color: var(--accent3); font-weight: 700; }
.log-entry .loss { color: var(--ok); }

#canvas-wrap { flex: 1; overflow: hidden; position: relative; }
canvas { display: block; }

#popup {
  display: none;
  position: fixed;
  z-index: 200;
  background: var(--surface);
  border: 1px solid var(--accent);
  border-radius: 10px;
  padding: 10px 12px;
  box-shadow: 0 10px 40px rgba(0,229,255,0.18);
  min-width: 175px;
}
#popup .pt { font-size: 11px; font-weight: 700; color: var(--text); margin-bottom: 6px; }
#popup label { font-size: 9px; color: var(--muted); display: block; margin-bottom: 3px; text-transform: uppercase; }
#popup input {
  width: 100%; background: var(--bg); border: 1px solid var(--border);
  color: var(--accent); font-family: 'JetBrains Mono', monospace;
  font-size: 12px; padding: 4px 7px; border-radius: 6px; outline: none;
}
#popup input:focus { border-color: var(--accent); }
#popup .popup-extra { margin-top: 7px; }

.legend {
  position: absolute;
  bottom: 12px; right: 12px;
  background: rgba(13,21,38,0.88);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 8px 11px;
  font-size: 9px;
  color: var(--muted);
  line-height: 1.9;
  backdrop-filter: blur(4px);
}
.legend b { color: var(--accent); }

.cscale {
  position: absolute;
  bottom: 12px; left: 12px;
  background: rgba(13,21,38,0.88);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 8px 11px;
  font-size: 9px;
  color: var(--muted);
  backdrop-filter: blur(4px);
}
.cscale .bar {
  width: 110px; height: 7px; border-radius: 4px; margin: 4px 0;
  background: linear-gradient(to right, #3c0080, #0a3090, #10b981, #f59e0b, #ef4444);
}
.cscale .bl { display: flex; justify-content: space-between; font-size: 8px; }
</style>
</head>
<body>

<header>
  <h1>â¬¡ NeuralGraph</h1>
  <span class="tag">VISUALIZER</span>
  <div id="batch-counter">Batch: <span id="bc">0</span></div>
  <div id="error-display" style="font-size:11px;color:var(--muted);margin-left:4px;">err: <span id="loss-display" style="color:var(--ok);font-weight:700;">â€”</span></div>
  <div id="api-status" style="font-size:10px;color:var(--accent3);margin-left:12px;">âŸ³ Connessione a /configâ€¦</div>
</header>

<div class="toolbar">
  <div class="ctrl-group">
    <label>Input</label>
    <input type="number" id="cfg-inputs" value="3" min="1" max="12">
  </div>
  <div class="ctrl-group">
    <label>Hidden L.</label>
    <input type="number" id="cfg-layers" value="2" min="0" max="6">
  </div>
  <div class="ctrl-group">
    <label>Nodes/L.</label>
    <input type="text" id="cfg-nodes" value="4" style="width:60px;background:transparent;border:none;color:var(--accent);font-family:'JetBrains Mono',monospace;font-size:13px;font-weight:700;outline:none;text-align:center;" placeholder="4 or 3,4,3">
  </div>
  <div class="ctrl-group">
    <label>Output</label>
    <input type="number" id="cfg-outputs" value="2" min="1" max="12">
  </div>
  <div class="ctrl-group">
    <label>Epochs</label>
    <input type="number" id="cfg-epochs" value="1" min="1" max="1000">
  </div>
  <div class="ctrl-group">
    <label>Batch size</label>
    <input type="number" id="cfg-batch" value="32" min="1" max="4096">
  </div>
  <button class="btn btn-ok" id="btn-train" onclick="runTrain()">âš¡ Train</button>
  <div class="sep"></div>
  <button class="btn btn-primary" id="btn-run" onclick="runInference()" title="POST /run â€” forward pass">â–· Run</button>
  <div class="sep"></div>
  <button class="btn btn-ghost" id="btn-save" onclick="saveParams()" title="POST /save">ğŸ’¾ Save</button>
  <button class="btn btn-ghost" id="btn-load" onclick="loadParams()" title="POST /load">ğŸ“‚ Load</button>
  <div class="sep"></div>
  <button class="btn btn-ghost" id="btn-reset" onclick="resetValues()">â†º Reset</button>
</div>

<div class="main">
  <div class="side">
    <div class="side-tabs">
      <div class="side-tab active" onclick="showTab('config')">CONFIG</div>
      <div class="side-tab" onclick="showTab('values')">VALUES</div>
      <div class="side-tab" onclick="showTab('log')">LOG</div>
    </div>

    <!-- CONFIG -->
    <div class="side-pane active" id="pane-config">
      <div class="side-scroll">
        <div class="json-section">
          <div class="json-label">
            Network structure + color ranges
            <a onclick="formatJson('ta-config')">format</a>
          </div>
          <textarea id="ta-config" rows="22"></textarea>
          <div class="json-err" id="err-config"></div>
          <button class="btn btn-primary apply-btn" onclick="applyConfig()">âœ“ Apply Config</button>
        </div>
      </div>
    </div>

    <!-- VALUES -->
    <div class="side-pane" id="pane-values">
      <div class="side-scroll">
        <div class="json-section">
          <div class="json-label">
            Valori nodi e pesi
            <a onclick="exportValues()">â†‘ export current</a>
          </div>
          <textarea id="ta-values" rows="22"></textarea>
          <div class="json-err" id="err-values"></div>
          <button class="btn btn-primary apply-btn" onclick="applyValues()">âœ“ Apply Values</button>
        </div>
      </div>
    </div>

    <!-- LOG -->
    <div class="side-pane" id="pane-log">
      <div id="train-log"><div style="color:var(--muted);font-size:9px;padding:6px">No batches run yet.</div></div>
    </div>
  </div>

  <div id="canvas-wrap">
    <canvas id="nn"></canvas>
    <div class="legend">
      <b>â—</b> Nodo: value (centro) / bias (top, b:â€¦)<br>
      <b>â”€</b> Synapse: weight Â· thickness = |weight|<br>
      Scroll to zoom Â· Drag to pan Â· Click to edit
    </div>
    <div class="cscale">
      <div>Color scale: min â†’ max</div>
      <div class="bar"></div>
      <div class="bl">
        <span id="scale-min">-1</span>
        <span>0</span>
        <span id="scale-max">1</span>
      </div>
    </div>
  </div>
</div>

<div id="popup">
  <div class="pt" id="pt"></div>
  <label id="pl">Value</label>
  <input id="pi" type="text" placeholder="0.000">
  <div class="popup-extra" id="popup-extra"></div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
//  CONFIG JSON â€” definisce la struttura della rete e i range colori.
//
//  Campi obbligatori:
//    inputs           : numero di nodi input
//    hidden_layers    : numero di layer nascosti
//    nodes_per_hidden : nodi in ogni hidden layer
//    outputs          : numero di nodi output
//
//  Campi opzionali (ranges) â€” usati per la colorazione:
//    value_min/max  : range valori di attivazione  (default: -1 / 1)
//    bias_min/max   : range bias                   (default: -1 / 1)
//    weight_min/max : range pesi                   (default: -2 / 2)
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const DEFAULT_CONFIG = {
  inputs: 3,
  hidden_layers: 2,
  nodes_per_hidden: 4,
  outputs: 2,
  ranges: {
    value_min: -1,
    value_max:  1,
    bias_min:  -1,
    bias_max:   1,
    weight_min: -2,
    weight_max:  2
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
//  VALUES JSON â€” popola la rete con valori concreti.
//
//  nodes   : array di oggetti nodo
//    layer  : indice layer (0 = input, 1..N = hidden, ultimo = output)
//    index  : indice del nodo nel layer (base 0)
//    value  : valore di attivazione (numero | null)
//    bias   : bias del nodo (numero | null) â€” ignorato per layer input
//
//  weights : array di oggetti peso
//    from_layer/from_index : nodo sorgente
//    to_layer/to_index     : nodo destinazione
//    weight                : valore del peso (numero | null)
//
//  Si possono fornire solo i valori che si vogliono sovrascrivere.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
//  VALUES JSON â€” schema compatto
//
//  inputs : array di numeri (valori di attivazione degli input)
//  layers : array di layer (hidden + output).
//           Ogni layer Ã¨ un array di nodi con:
//             value   : valore di attivazione
//             bias    : bias del nodo
//             weights : array di pesi in ingresso dal layer precedente
//                       (uno per ogni nodo del layer precedente,
//                        nell'ordine in cui compaiono)
//
//  Esempio per rete 3-input â†’ [4 hidden] â†’ [4 hidden] â†’ 2-output:
//
//    inputs:  [v0, v1, v2]           â† plain numbers
//    layers[0]: 4 elementi {value, bias, weights:[w0,w1,w2]}      â† 3 pesi da input
//    layers[1]: 4 elementi {value, bias, weights:[w0,w1,w2,w3]}   â† 4 pesi da hidden[0]
//    layers[2]: 2 elementi {value, bias, weights:[w0,w1,w2,w3]}   â† 4 pesi da hidden[1]
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const EXAMPLE_VALUES = {
  inputs: [0.80, -0.30, 0.50],
  layers: [
    [
      {value:  0.42, bias:  0.10, weights: [ 0.50, -1.20,  0.00]},
      {value: -0.70, bias: -0.30, weights: [ 0.80,  0.00,  0.00]},
      {value:  0.15, bias:  0.50, weights: [ 0.00, -0.30,  0.00]},
      {value:  0.90, bias: -0.10, weights: [ 0.00,  0.00,  1.50]}
    ],
    [
      {value:  0.33, bias:  0.20, weights: [ 0.90,  0.00,  0.00,  0.00]},
      {value: -0.55, bias: -0.40, weights: [ 0.00, -1.80,  0.00,  0.00]},
      {value:  0.78, bias:  0.00, weights: [ 0.00,  0.00,  0.40,  0.00]},
      {value: -0.20, bias:  0.30, weights: [ 0.00,  0.00,  0.00, -0.70]}
    ],
    [
      {value:  0.61, bias:  0.05, weights: [ 1.10,  0.00,  0.00,  0.00]},
      {value: -0.44, bias: -0.20, weights: [ 0.00,  0.00, -0.90,  0.00]}
    ]
  ]
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CORE STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const canvas = document.getElementById('nn');
const ctx    = canvas.getContext('2d');
const wrap   = document.getElementById('canvas-wrap');

let nodes    = [];  // {x,y,r, layer,index,type, value,bias}
let synapses = [];  // {from,to, weight, mx,my}
let hovered  = null;
let editing  = null;
let transform = {tx:0, ty:0, scale:1};
let dragging  = false, dragStart = null;
let batchCount = 0;

let currentConfig = JSON.parse(JSON.stringify(DEFAULT_CONFIG));

const R = 26;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  COLOR UTILS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function lerp(a,b,t){ return a+(b-a)*Math.max(0,Math.min(1,t)); }

// 5-stop gradient: cold purple â†’ deep blue â†’ green â†’ amber â†’ hot red
const COLOR_STOPS = [
  [0.00, [60,   0, 120]],
  [0.25, [10,  50, 160]],
  [0.50, [16, 185, 129]],
  [0.75, [245,158,  11]],
  [1.00, [239, 68,  68]]
];

function valToRGB(val, min, max){
  const t = Math.max(0, Math.min(1, (val - min) / (max - min || 1)));
  for(let i=1; i<COLOR_STOPS.length; i++){
    const [t0,c0] = COLOR_STOPS[i-1];
    const [t1,c1] = COLOR_STOPS[i];
    if(t <= t1){
      const f = (t-t0)/(t1-t0);
      return [
        Math.round(lerp(c0[0],c1[0],f)),
        Math.round(lerp(c0[1],c1[1],f)),
        Math.round(lerp(c0[2],c1[2],f))
      ];
    }
  }
  return [239,68,68];
}

function valToColor(val, min, max){
  const [r,g,b] = valToRGB(val,min,max);
  return `rgb(${r},${g},${b})`;
}

function valToColorA(val, min, max, a){
  const [r,g,b] = valToRGB(val,min,max);
  return `rgba(${r},${g},${b},${a})`;
}

function weightToWidth(w, min, max){
  const absMax = Math.max(Math.abs(min), Math.abs(max), 0.001);
  return Math.min(12, 0.5 + (Math.abs(w)/absMax)*4.5);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BUILD NETWORK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildFromUI(){
  const nphRaw = document.getElementById('cfg-nodes').value.trim();
  // Parse "3,4,3" â†’ [3,4,3] or "4" â†’ 4
  const nph = nphRaw.includes(',')
    ? nphRaw.split(',').map(x=>Math.max(1,parseInt(x.trim())||1))
    : Math.max(1, parseInt(nphRaw)||4);
  const cfg = {
    inputs:           Math.max(1, parseInt(document.getElementById('cfg-inputs').value)||3),
    hidden_layers:    Math.max(0, parseInt(document.getElementById('cfg-layers').value)||2),
    nodes_per_hidden: nph,
    outputs:          Math.max(1, parseInt(document.getElementById('cfg-outputs').value)||2),
    ranges: currentConfig.ranges
  };
  currentConfig = cfg;
  buildFromConfig(cfg);
  syncConfigTA();
}

function buildFromConfig(cfg){
  // Sync controls
  document.getElementById('cfg-inputs').value  = cfg.inputs;
  document.getElementById('cfg-layers').value  = cfg.hidden_layers;
  document.getElementById('cfg-nodes').value   = Array.isArray(cfg.nodes_per_hidden)
    ? cfg.nodes_per_hidden.join(',')
    : cfg.nodes_per_hidden;
  document.getElementById('cfg-outputs').value = cfg.outputs;

  // Scale labels
  const r = cfg.ranges || {};
  document.getElementById('scale-min').textContent = r.value_min ?? -1;
  document.getElementById('scale-max').textContent = r.value_max ??  1;

  nodes    = [];
  synapses = [];
  editing  = null;
  hidePopup();

  const layers = [];
  layers.push({count: cfg.inputs, type:'input'});
  for(let i=0;i<cfg.hidden_layers;i++){
    // nodes_per_hidden can be a number OR an array [n1, n2, ...]
    const nph = Array.isArray(cfg.nodes_per_hidden)
      ? (cfg.nodes_per_hidden[i] ?? cfg.nodes_per_hidden[cfg.nodes_per_hidden.length-1])
      : cfg.nodes_per_hidden;
    layers.push({count: nph, type:'hidden'});
  }
  layers.push({count: cfg.outputs, type:'output'});

  const cw = wrap.clientWidth;
  const ch = wrap.clientHeight;
  canvas.width  = cw;
  canvas.height = ch;

  const padX=90, padY=55;
  const stepX = layers.length>1 ? (cw-padX*2)/(layers.length-1) : (cw-padX*2)/2;

  layers.forEach((layer,li) => {
    const x = padX + li*stepX;
    for(let ni=0; ni<layer.count; ni++){
      const stepY = layer.count>1 ? (ch-padY*2)/(layer.count-1) : 0;
      const y = layer.count===1 ? ch/2 : padY + ni*stepY;
      nodes.push({x,y,r:R, layer:li, index:ni, type:layer.type, value:null, bias:null});
    }
  });

  // Full mesh between consecutive layers
  for(let li=0; li<layers.length-1; li++){
    const from = nodes.filter(n=>n.layer===li);
    const to   = nodes.filter(n=>n.layer===li+1);
    from.forEach(fn => to.forEach(tn => {
      synapses.push({from:fn, to:tn, weight:null, mx:(fn.x+tn.x)/2, my:(fn.y+tn.y)/2});
    }));
  }

  transform = {tx:0, ty:0, scale:1};
  draw();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DRAW
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function fmt(v){
  if(v===null||v===undefined||v==='') return '';
  const n=parseFloat(v);
  if(isNaN(n)) return String(v).slice(0,7);
  if(Math.abs(n)<0.0001 && n!==0) return n.toExponential(1);
  return parseFloat(n.toFixed(4)).toString().slice(0,7);
}

function draw(){
  const {tx,ty,scale} = transform;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGrid();

  ctx.save();
  ctx.translate(tx,ty);
  ctx.scale(scale,scale);

  const r = currentConfig.ranges || {};
  const wmin=r.weight_min??-2, wmax=r.weight_max??2;
  const vmin=r.value_min??-1,  vmax=r.value_max??1;
  const bmin=r.bias_min??-1,   bmax=r.bias_max??1;

  // â”€â”€ Synapses â”€â”€
  synapses.forEach(s => {
    const isHov = hovered?.type==='synapse' && hovered.obj===s;
    const hasW  = s.weight !== null && s.weight !== undefined && s.weight !== '';
    const wNum  = hasW ? parseFloat(s.weight) : 0;

    ctx.beginPath();
    ctx.moveTo(s.from.x, s.from.y);
    ctx.lineTo(s.to.x, s.to.y);

    if(hasW){
      ctx.strokeStyle  = isHov ? '#ffffff' : valToColor(wNum, wmin, wmax);
      ctx.lineWidth    = Math.min(12, weightToWidth(wNum, wmin, wmax) * (isHov ? 1.5 : 1));
      ctx.globalAlpha  = isHov ? 1 : 0.6;
    } else {
      ctx.strokeStyle  = isHov ? '#4a90d9' : 'rgba(26,45,74,0.35)';
      ctx.lineWidth    = isHov ? 1.5 : 0.6;
      ctx.globalAlpha  = 1;
    }
    ctx.stroke();
    ctx.globalAlpha = 1;

    if(hasW)            drawLabel(s.mx, s.my, fmt(wNum), '#f59e0b', isHov);
    else if(isHov)      drawHint(s.mx, s.my, '+ weight');
  });

  // â”€â”€ Layer labels â”€â”€
  const layerNums = [...new Set(nodes.map(n=>n.layer))];
  const totalL = layerNums.length;
  layerNums.forEach(li => {
    const ln = nodes.filter(n=>n.layer===li);
    if(!ln.length) return;
    const x    = ln[0].x;
    const topY = Math.min(...ln.map(n=>n.y)) - R - 14;
    const lbl  = li===0 ? 'INPUT' : li===totalL-1 ? 'OUTPUT' : `HIDDEN ${li}`;
    ctx.save();
    ctx.font        = '9px JetBrains Mono';
    ctx.fillStyle   = 'rgba(74,96,128,0.65)';
    ctx.textAlign   = 'center';
    ctx.textBaseline= 'bottom';
    ctx.fillText(lbl, x, topY);
    ctx.restore();
  });

  // â”€â”€ Nodes â”€â”€
  nodes.forEach(n => {
    const isHov = hovered?.type==='node' && hovered.obj===n;
    const hasV  = n.value !== null && n.value !== undefined && n.value !== '';
    const vNum  = hasV ? parseFloat(n.value) : null;
    const hasB  = n.bias !== null && n.bias !== undefined && n.bias !== '' && n.type!=='input';

    // Fill
    let fill = '#0a1424';
    if(hasV && !isNaN(vNum)) fill = valToColorA(vNum, vmin, vmax, 0.22);

    // Stroke
    let stroke = n.type==='input' ? '#1a4060' : n.type==='output' ? '#3a1060' : '#1a2d5a';
    if(hasV && !isNaN(vNum)) stroke = valToColor(vNum, vmin, vmax);
    if(isHov) stroke = '#ffffff';

    ctx.beginPath();
    ctx.arc(n.x, n.y, n.r, 0, Math.PI*2);
    ctx.fillStyle = fill;
    ctx.fill();

    if(isHov){ ctx.shadowBlur=16; ctx.shadowColor=stroke; }
    ctx.strokeStyle = stroke;
    ctx.lineWidth   = isHov ? 2.5 : 1.8;
    ctx.stroke();
    ctx.shadowBlur  = 0;

    // Value text (center)
    if(hasV){
      ctx.save();
      ctx.font         = 'bold 9px JetBrains Mono';
      ctx.fillStyle    = '#e2e8f0';
      ctx.textAlign    = 'center';
      ctx.textBaseline = hasB ? 'alphabetic' : 'middle';
      ctx.fillText(fmt(vNum), n.x, hasB ? n.y+3 : n.y);
      ctx.restore();
    } else if(isHov){
      drawHint(n.x, n.y, 'âœ');
    }

    // Bias (top of node, small)
    if(hasB){
      const bNum = parseFloat(n.bias);
      ctx.save();
      ctx.font         = '7px JetBrains Mono';
      ctx.fillStyle    = valToColor(bNum, bmin, bmax);
      ctx.textAlign    = 'center';
      ctx.textBaseline = 'top';
      ctx.fillText('b:'+fmt(bNum), n.x, n.y - n.r + 3);
      ctx.restore();
    }
  });

  ctx.restore();
}

function drawLabel(x,y,txt,color,isHov){
  ctx.save();
  ctx.font         = 'bold 8px JetBrains Mono';
  ctx.textAlign    = 'center';
  ctx.textBaseline = 'middle';
  const w = ctx.measureText(txt).width + 6;
  ctx.fillStyle = 'rgba(7,11,20,0.88)';
  ctx.fillRect(x-w/2, y-7, w, 14);
  ctx.fillStyle = isHov ? '#fff' : color;
  ctx.fillText(txt, x, y);
  ctx.restore();
}

function drawHint(x,y,txt){
  ctx.save();
  ctx.font         = '9px JetBrains Mono';
  ctx.fillStyle    = 'rgba(0,180,255,0.55)';
  ctx.textAlign    = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(txt, x, y);
  ctx.restore();
}

function drawGrid(){
  const {tx,ty,scale} = transform;
  const step = 40*scale;
  ctx.strokeStyle = 'rgba(26,45,74,0.3)';
  ctx.lineWidth   = 0.5;
  for(let x=(tx%step+step)%step; x<canvas.width;  x+=step){
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();
  }
  for(let y=(ty%step+step)%step; y<canvas.height; y+=step){
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INTERACTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function toWorld(px,py){
  return {x:(px-transform.tx)/transform.scale, y:(py-transform.ty)/transform.scale};
}

function getHit(wx,wy){
  for(const n of nodes){
    const dx=n.x-wx, dy=n.y-wy;
    if(dx*dx+dy*dy<=n.r*n.r) return {type:'node',obj:n};
  }
  for(const s of synapses){
    const dx=s.mx-wx, dy=s.my-wy;
    if(dx*dx+dy*dy<16*16) return {type:'synapse',obj:s};
  }
  return null;
}

canvas.addEventListener('mousemove', e=>{
  if(dragging){
    transform.tx = dragStart.tx + (e.clientX-dragStart.x);
    transform.ty = dragStart.ty + (e.clientY-dragStart.y);
    draw(); return;
  }
  const rc = canvas.getBoundingClientRect();
  const {x,y} = toWorld(e.clientX-rc.left, e.clientY-rc.top);
  const hit = getHit(x,y);
  if(hit !== hovered){ hovered=hit; draw(); }
  canvas.style.cursor = hit ? 'pointer' : 'grab';
});

canvas.addEventListener('mousedown', e=>{
  if(e.button!==0) return;
  const rc = canvas.getBoundingClientRect();
  const {x,y} = toWorld(e.clientX-rc.left, e.clientY-rc.top);
  const hit = getHit(x,y);
  if(hit){
    openPopup(hit, e.clientX, e.clientY);
  } else {
    dragging  = true;
    dragStart = {x:e.clientX,y:e.clientY,tx:transform.tx,ty:transform.ty};
    canvas.style.cursor = 'grabbing';
    hidePopup();
  }
});
canvas.addEventListener('mouseup',   ()=>{ dragging=false; canvas.style.cursor='grab'; });
canvas.addEventListener('mouseleave',()=>{ dragging=false; hovered=null; draw(); });
canvas.addEventListener('wheel', e=>{
  e.preventDefault();
  const rc=canvas.getBoundingClientRect();
  const mx=e.clientX-rc.left, my=e.clientY-rc.top;
  const delta = e.deltaY>0 ? 0.88 : 1.13;
  const ns = Math.min(4, Math.max(0.2, transform.scale*delta));
  transform.tx = mx-(mx-transform.tx)*(ns/transform.scale);
  transform.ty = my-(my-transform.ty)*(ns/transform.scale);
  transform.scale = ns;
  draw();
},{passive:false});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  POPUP EDITOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const popup = document.getElementById('popup');
const pi    = document.getElementById('pi');

function openPopup(hit, cx, cy){
  editing = hit;
  const isN = hit.type==='node';

  document.getElementById('pt').textContent = isN
    ? `Node  L${hit.obj.layer} Â· N${hit.obj.index}  [${hit.obj.type}]`
    : `Weight  L${hit.obj.from.layer}Â·${hit.obj.from.index} â†’ L${hit.obj.to.layer}Â·${hit.obj.to.index}`;

  const extra = document.getElementById('popup-extra');

  if(isN){
    document.getElementById('pl').textContent = 'Activation value';
    pi.value = hit.obj.value ?? '';
    pi.dataset.field = 'value';
    pi.placeholder = 'e.g. 0.75';

    // Extra bias field for non-input nodes
    if(hit.obj.type !== 'input'){
      extra.innerHTML = `
        <label style="font-size:9px;color:var(--muted);text-transform:uppercase;display:block;margin-bottom:3px;margin-top:7px">Bias</label>
        <input id="pi-bias" type="text" placeholder="e.g. -0.1"
          style="width:100%;background:var(--bg);border:1px solid var(--border);
          color:#f59e0b;font-family:'JetBrains Mono',monospace;font-size:12px;
          padding:4px 7px;border-radius:6px;outline:none;"
          value="${hit.obj.bias ?? ''}">`;
      const pb = document.getElementById('pi-bias');
      pb.addEventListener('input', ()=>{
        if(editing?.type==='node') editing.obj.bias = pb.value==='' ? null : pb.value;
        draw();
      });
      pb.addEventListener('focus', ()=>{ pb.style.borderColor='var(--accent3)'; });
      pb.addEventListener('blur',  ()=>{ pb.style.borderColor='var(--border)'; });
    } else {
      extra.innerHTML = '';
    }
  } else {
    document.getElementById('pl').textContent = 'Weight';
    pi.value = hit.obj.weight ?? '';
    pi.placeholder = 'e.g. -1.2';
    pi.dataset.field = 'weight';
    extra.innerHTML = '';
  }

  popup.style.display='block';
  let l=cx+14, t=cy+14;
  if(l+190>window.innerWidth)  l=cx-200;
  if(t+120>window.innerHeight) t=cy-120;
  popup.style.left=l+'px'; popup.style.top=t+'px';
  setTimeout(()=>pi.focus(),10);
}

function hidePopup(){ popup.style.display='none'; editing=null; }

pi.addEventListener('input', ()=>{
  if(!editing) return;
  const v = pi.value;
  if(editing.type==='node')     editing.obj.value  = v==='' ? null : v;
  else                          editing.obj.weight = v==='' ? null : v;
  draw();
});
pi.addEventListener('keydown', e=>{ if(e.key==='Enter'||e.key==='Escape') hidePopup(); });
document.addEventListener('mousedown', e=>{
  if(!popup.contains(e.target) && e.target!==canvas) hidePopup();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  JSON CONFIG â€” apply & sync
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function syncConfigTA(){
  document.getElementById('ta-config').value = JSON.stringify(currentConfig, null, 2);
}

// Serialize current node/synapse state into the VALUES textarea
function syncValuesTA(){
  const inputNodes = nodes.filter(n=>n.layer===0).sort((a,b)=>a.index-b.index);
  const layerNums  = [...new Set(nodes.map(n=>n.layer))].sort((a,b)=>a-b).slice(1);
  const out = {
    inputs: inputNodes.map(n=> n.value ?? null),
    overall_mean_out_error: (() => {
      const el = document.getElementById('loss-display');
      const v = el ? parseFloat(el.textContent) : NaN;
      return isNaN(v) ? null : v;
    })(),
    layers: layerNums.map(li=>{
      const layerNodes = nodes.filter(n=>n.layer===li).sort((a,b)=>a.index-b.index);
      return layerNodes.map(n=>{
        const prevCount = nodes.filter(x=>x.layer===li-1).length;
        const weights = Array.from({length: prevCount}, (_, fromIdx)=>{
          const s = synapses.find(x=>
            x.from.layer===li-1 && x.from.index===fromIdx &&
            x.to.layer===li     && x.to.index===n.index);
          return s ? (s.weight ?? null) : null;
        });
        return { value: n.value ?? null, bias: n.bias ?? null, weights };
      });
    })
  };
  document.getElementById('ta-values').value = JSON.stringify(out, null, 2);
}

function applyConfig(){
  const el  = document.getElementById('ta-config');
  const err = document.getElementById('err-config');
  try {
    const cfg = JSON.parse(el.value);
    if(typeof cfg.inputs!=='number'||typeof cfg.outputs!=='number')
      throw new Error("inputs e outputs devono essere numeri");
    currentConfig = cfg;
    buildFromConfig(cfg);
    err.textContent = '';
  } catch(e){ err.textContent = 'âœ• '+e.message; }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  JSON VALUES â€” apply & export
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function applyValues(){
  const el  = document.getElementById('ta-values');
  const err = document.getElementById('err-values');
  try {
    const data = JSON.parse(el.value);
    loadValuesData(data);
    err.textContent = '';
    draw();
    syncValuesTA();
  } catch(e){ err.textContent = 'âœ• '+e.message; }
}

// Accepts the compact schema:
// { inputs:[0.8, -0.3, ...], overall_mean_out_error: 0.012, layers:[[{value,bias,weights:[...]},...],...] }
function loadValuesData(data){
  if(!data) return;

  // â”€â”€ overall_mean_out_error â†’ loss display â”€â”€
  if(data.overall_mean_out_error !== undefined && data.overall_mean_out_error !== null){
    const el = document.getElementById('loss-display');
    if(el) el.textContent = fmt(data.overall_mean_out_error);
  }

  // â”€â”€ inputs: plain numbers (accepts also legacy {value} objects) â”€â”€
  if(data.inputs){
    data.inputs.forEach((inp, idx)=>{
      const n = nodes.find(x=>x.layer===0 && x.index===idx);
      if(!n) return;
      const v = (typeof inp === 'object' && inp !== null) ? inp.value : inp;
      if(v !== undefined && v !== null) n.value = v;
    });
  }

  // â”€â”€ layers (hidden + output) â”€â”€
  if(data.layers){
    data.layers.forEach((layer, li)=>{
      const layerIdx = li + 1; // layer 0 = inputs, so hidden/output start at 1
      layer.forEach((nd, ni)=>{
        const n = nodes.find(x=>x.layer===layerIdx && x.index===ni);
        if(!n) return;
        if(nd.value !== undefined) n.value = nd.value;
        if(nd.bias  !== undefined) n.bias  = nd.bias;

        // weights[k] = weight from node k of the previous layer to this node
        if(nd.weights){
          nd.weights.forEach((w, fromIdx)=>{
            const s = synapses.find(x=>
              x.from.layer === layerIdx-1 &&
              x.from.index === fromIdx    &&
              x.to.layer   === layerIdx   &&
              x.to.index   === ni);
            if(s) s.weight = w;
          });
        }
      });
    });
  }
}

function exportValues(){
  syncValuesTA();
  showTab('values');
}

function formatJson(id){
  const ta = document.getElementById(id);
  try { ta.value = JSON.stringify(JSON.parse(ta.value),null,2); } catch(_){}
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  API CALLS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// GET /config  â†’  network structure + ranges
async function fetchConfig(){
  setStatus('loading', 'âŸ³ Loading configâ€¦');
  try {
    const res  = await fetch('/config');
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const cfg  = await res.json();
    currentConfig = cfg;
    buildFromConfig(cfg);
    syncConfigTA();
    setStatus('ok', 'âœ“ Config loaded from /config');
  } catch(e){
    setStatus('err', `âœ• /config: ${e.message} â€” using default`);
    // Fallback to built-in default
    buildFromConfig(currentConfig);
    syncConfigTA();
  }
}

// POST /train
// Request body:  { epochs: N, batch_size: M }
// Response body (compact schema):
// {
//   inputs: [0.8, -0.3, 0.5, ...],                    â† plain numbers
//   overall_mean_out_error: 0.00312,                   â† shown as loss in GUI
//   layers: [
//     [{value, bias, weights:[...]}, ...],             â† hidden layers
//     [{value, bias, weights:[...]}, ...]              â† output layer
//   ]
// }
function getRunParams(){
  return {
    epochs:     Math.max(1, parseInt(document.getElementById('cfg-epochs').value) || 1),
    batch_size: Math.max(1, parseInt(document.getElementById('cfg-batch').value)  || 32)
  };
}

async function callTrain(){
  const body = getRunParams();
  const res = await fetch('/train', {
    method:  'POST',
    headers: {'Content-Type': 'application/json'},
    body:    JSON.stringify(body)
  });
  if(!res.ok) throw new Error(`HTTP ${res.status}`);
  return res.json();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TRAINING â€” driven by POST /train
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function runTrain(){
  if(!nodes.length){ alert('Build the network first!'); return; }
  const p = getRunParams();
  const btn = document.getElementById('btn-train');
  btn.disabled = true;
  setStatus('loading', `âŸ³ /train (epochs:${p.epochs} batch:${p.batch_size})â€¦`);
  try {
    const data = await callTrain();
    loadValuesData(data);
    batchCount++;
    document.getElementById('bc').textContent = batchCount;
    const loss = data.overall_mean_out_error ?? data.loss ?? 'â€”';
    logEntry(batchCount, loss, p);
    draw();
    syncValuesTA();
    setStatus('ok', `âœ“ Train #${batchCount} â€” err: ${loss}`);
  } catch(e){
    setStatus('err', `âœ• /train: ${e.message}`);
    logError(e.message);
  } finally {
    btn.disabled = false;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RUN (INFERENCE)  â€” POST /run
//
//  Request body:  { inputs: [v0, v1, ...] }   â† plain numbers from input nodes
//  Response body: { outputs: [v0, v1, ...] }   â† plain numbers, one per output node
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function runInference(){
  if(!nodes.length){ alert('Build the network first!'); return; }
  const btn = document.getElementById('btn-run');
  btn.disabled = true;
  setStatus('loading', 'âŸ³ /runâ€¦');

  // Read current input values from the graph
  const inputNodes = nodes
    .filter(n => n.layer === 0)
    .sort((a,b) => a.index - b.index);
  const inputs = inputNodes.map(n => {
    const v = parseFloat(n.value);
    return isNaN(v) ? 0 : v;
  });

  try {
    const res = await fetch('/run', {
      method:  'POST',
      headers: {'Content-Type': 'application/json'},
      body:    JSON.stringify({ inputs })
    });
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();

    // data.outputs: array of numbers, one per output node
    if(Array.isArray(data.outputs)){
      const maxLayerIdx = Math.max(...nodes.map(n => n.layer));
      const outputNodes = nodes
        .filter(n => n.layer === maxLayerIdx)
        .sort((a,b) => a.index - b.index);
      data.outputs.forEach((v, i) => {
        if(outputNodes[i]) outputNodes[i].value = v;
      });
    }

    draw();
    syncValuesTA();

    const outStr = Array.isArray(data.outputs)
      ? '[' + data.outputs.map(v => fmt(v)).join(', ') + ']'
      : 'â€”';
    setStatus('ok', `âœ“ Run â†’ outputs: ${outStr}`);
    logEntry('RUN', outStr);
  } catch(e){
    setStatus('err', `âœ• /run: ${e.message}`);
    logError('run: ' + e.message);
  } finally {
    btn.disabled = false;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SAVE / LOAD / RESET  â€” POST /save, POST /load, POST /reset
//
//  POST /save   body: { inputs:[...], layers:[...] }   â† compact schema
//               response: { ok: true } or { ok: false, error: '...' }
//
//  POST /load   body: {}
//               response: same compact schema as /train
//               { inputs:[...], overall_mean_out_error, layers:[...] }
//
//  POST /reset  body: {}
//               response: same compact schema as /train
//               { inputs:[...], overall_mean_out_error, layers:[...] }
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function saveParams(){
  // Serialize using the compact schema
  const inputNodes = nodes.filter(n=>n.layer===0).sort((a,b)=>a.index-b.index);
  const layerNums  = [...new Set(nodes.map(n=>n.layer))].sort((a,b)=>a-b).slice(1);
  const payload = {
    inputs: inputNodes.map(n=> n.value ?? null),
    layers: layerNums.map(li=>{
      const layerNodes = nodes.filter(n=>n.layer===li).sort((a,b)=>a.index-b.index);
      return layerNodes.map(n=>{
        const prevCount = nodes.filter(x=>x.layer===li-1).length;
        const weights = Array.from({length: prevCount}, (_, fromIdx)=>{
          const s = synapses.find(x=>
            x.from.layer===li-1 && x.from.index===fromIdx &&
            x.to.layer===li     && x.to.index===n.index);
          return s ? s.weight : null;
        });
        return { value: n.value, bias: n.bias, weights };
      });
    })
  };
  const btn = document.getElementById('btn-save');
  btn.disabled = true;
  setStatus('loading', 'âŸ³ Savingâ€¦');
  try {
    const res = await fetch('/save', {
      method:  'POST',
      headers: {'Content-Type': 'application/json'},
      body:    JSON.stringify(payload)
    });
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    if(data.ok === false) throw new Error(data.error || 'Risposta negativa dal server');
    setStatus('ok', 'âœ“ Parameters saved');
    logEntry('SAVE', 'â€”');
  } catch(e){
    setStatus('err', `âœ• /save: ${e.message}`);
    logError('save: '+e.message);
  } finally {
    btn.disabled = false;
  }
}

async function loadParams(){
  const btn = document.getElementById('btn-load');
  btn.disabled = true;
  setStatus('loading', 'âŸ³ /loadâ€¦');
  try {
    const res = await fetch('/load', {
      method:  'POST',
      headers: {'Content-Type': 'application/json'},
      body:    JSON.stringify({})
    });
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    loadValuesData(data);
    draw();
    syncValuesTA();
    const err = data.overall_mean_out_error ?? 'â€”';
    setStatus('ok', `âœ“ Load â€” err: ${err}`);
    logEntry('LOAD', err);
  } catch(e){
    setStatus('err', `âœ• /load: ${e.message}`);
    logError('load: '+e.message);
  } finally {
    btn.disabled = false;
  }
}

function logEntry(batch, loss, params){
  const log = document.getElementById('train-log');
  if(log.children.length===1 && !log.firstChild.className) log.innerHTML='';
  const div = document.createElement('div');
  div.className='log-entry';
  const ts = new Date().toLocaleTimeString('it-IT',{hour12:false});
  const isMeta = (batch==='SAVE'||batch==='LOAD'||batch==='RESET'||batch==='RUN');
  const pInfo = (!isMeta && params) ? ` <span style="color:var(--muted);font-size:8px">e:${params.epochs} b:${params.batch_size}</span>` : '';
  const lossHtml = isMeta
    ? `<span style="color:var(--accent2)">${batch}</span>`
    : `<span class="li">#${batch}</span>${pInfo} loss: <span class="loss">${loss}</span>`;
  div.innerHTML=`<span style="color:var(--muted)">${ts}</span> ${lossHtml}`;
  log.appendChild(div);
  log.scrollTop = log.scrollHeight;
  while(log.children.length>400) log.removeChild(log.firstChild);
}

function logError(msg){
  const log = document.getElementById('train-log');
  if(log.children.length===1 && !log.firstChild.className) log.innerHTML='';
  const div = document.createElement('div');
  div.className='log-entry';
  div.innerHTML=`<span style="color:var(--danger)">âœ• ${msg}</span>`;
  log.appendChild(div);
  log.scrollTop = log.scrollHeight;
}

// Status bar in header
function setStatus(type, msg){
  const el = document.getElementById('api-status');
  el.textContent = msg;
  el.style.color = type==='ok'      ? 'var(--ok)'
                 : type==='err'     ? 'var(--danger)'
                 : type==='warn'    ? 'var(--accent3)'
                 : /* loading */      'var(--accent)';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TABS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function showTab(name){
  const names=['config','values','log'];
  document.querySelectorAll('.side-tab').forEach((t,i)=>{
    t.classList.toggle('active', names[i]===name);
  });
  document.querySelectorAll('.side-pane').forEach((p,i)=>{
    p.classList.toggle('active', names[i]===name);
  });
}

async function resetValues(){
  const btn = document.getElementById('btn-reset');
  btn.disabled = true;
  setStatus('loading', 'âŸ³ /resetâ€¦');
  try {
    const res = await fetch('/reset', {
      method:  'POST',
      headers: {'Content-Type': 'application/json'},
      body:    JSON.stringify({})
    });
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    batchCount = 0;
    document.getElementById('bc').textContent = '0';
    document.getElementById('loss-display').textContent = 'â€”';
    loadValuesData(data);
    draw();
    syncValuesTA();
    const err = data.overall_mean_out_error ?? 'â€”';
    setStatus('ok', `âœ“ Reset â€” err: ${err}`);
    logEntry('RESET', err);
  } catch(e){
    setStatus('err', `âœ• /reset: ${e.message}`);
    logError('reset: '+e.message);
  } finally {
    btn.disabled = false;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RESIZE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const ro = new ResizeObserver(()=>{
  if(!nodes.length) return;
  // Save current values using compact schema
  const inputNodes = nodes.filter(n=>n.layer===0).sort((a,b)=>a.index-b.index);
  const layerNums  = [...new Set(nodes.map(n=>n.layer))].sort((a,b)=>a-b).slice(1);
  const snapshot = {
    inputs: inputNodes.map(n=> n.value ?? null),
    layers: layerNums.map(li=>{
      const layerNodes = nodes.filter(n=>n.layer===li).sort((a,b)=>a.index-b.index);
      return layerNodes.map(n=>{
        const prevCount = nodes.filter(x=>x.layer===li-1).length;
        const weights = Array.from({length: prevCount}, (_, fromIdx)=>{
          const s = synapses.find(x=>
            x.from.layer===li-1 && x.from.index===fromIdx &&
            x.to.layer===li     && x.to.index===n.index);
          return s ? s.weight : null;
        });
        return { value: n.value, bias: n.bias, weights };
      });
    })
  };
  buildFromConfig(currentConfig);
  loadValuesData(snapshot);
  draw();
  syncValuesTA();
});
ro.observe(wrap);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INIT â€” fetch config from API on page load
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
syncConfigTA();
// ta-values is populated dynamically via syncValuesTA() after each API response
fetchConfig();  // â† calls /config, falls back to DEFAULT_CONFIG on error
</script>
</body>
</html>